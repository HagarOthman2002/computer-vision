# -*- coding: utf-8 -*-
"""image Segmentation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n_buw0r_-OZ5OrU92rXqL4kHMofI3o4v
"""

import cv2
import matplotlib.pyplot as plt
import numpy as np
from google.colab.patches import cv2_imshow

"""#Simple thresholding"""

#binary threshold
plt.figure(figsize=(10,10))
image= cv2.imread("/content/classic.jpg")
#true if the filter could be applied on the image
TOF,THRESHOLD = cv2.threshold(image,100,255 , cv2.THRESH_BINARY) #threshold value, 255 for maximum value of gray image
plt.subplot(1,2,1)
plt.imshow(image)
plt.subplot(1,2,2)
plt.imshow(THRESHOLD)

#inverse Binary
plt.figure(figsize=(10,10))
image = cv2.imread("/content/classic.jpg")
TOF,thresh = cv2.threshold(image,100,255,cv2.THRESH_BINARY_INV)
plt.subplot(1,2,1)
plt.imshow(image)
plt.subplot(1,2,2)
plt.imshow(thresh)

from os import truncate
#trunc
plt.figure(figsize=(10,10))
image = cv2.imread("/content/classic.jpg")
TOF,THRESHOLD= cv2.threshold(image,100,255,cv2.THRESH_TRUNC)  #by5ly 3nd al threshold 5t abyad
plt.subplot(1,2,1)
plt.imshow(image)
plt.subplot(1,2,2)
plt.imshow(THRESHOLD)

#to zero

#inverse to zero
plt.figure(figsize=(10,10))
image = cv2.imread("/content/classic.jpg")
TOF,THRESH = cv2.threshold(image, 100 , 255 , cv2.THRESH_TOZERO)
plt.subplot(1,2,1)
plt.imshow(image)
plt.subplot(1,2,2)
plt.imshow(THRESH)

#inverse to zero
plt.figure(figsize=(10,10))
image = cv2.imread("/content/classic.jpg")
TOF,THRESH = cv2.threshold(image, 100 , 255 , cv2.THRESH_TOZERO_INV)
plt.subplot(1,2,1)
plt.imshow(image)
plt.subplot(1,2,2)
plt.imshow(THRESH)

"""#Adaptive"""

image = cv2.imread("/content/sudoko.jpg")
TOF,THRESHold = cv2.threshold(image ,100 , 255,cv2.THRESH_BINARY)
plt.figure(figsize=(10,10))
plt.subplot(1,2,1)
plt.imshow(image)
plt.subplot(1,2,2)
plt.imshow(THRESHold)

#Adaptive_threshold_C
image = cv2.imread("/content/sudoko.jpg",0)
THRESHold = cv2.adaptiveThreshold(image , 255,cv2.ADAPTIVE_THRESH_MEAN_C ,cv2.THRESH_BINARY ,111,2) #
cv2_imshow(THRESHold)

#Adaptive_threshold_Gaussian_c
image = cv2.imread("/content/sudoko.jpg",0)
THRESHold = cv2.adaptiveThreshold(image , 255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C ,cv2.THRESH_BINARY ,111,2) #
cv2_imshow(THRESHold)

"""#**OTSU thresholding**

OTSU algorithm steps :
 1. draw histogram for the gray levels
 2. choose random threshold
 3. claculate 4 diffrent variable (Background weight (Wb) ,  forground weigh(fb) ,Ub , Uf)
 4.  apply OTSU rule
 5. Repeat the steps again
"""

image = cv2.imread("/content/O_12.png",0)
#apply gaussian filter
gausssian_filter = cv2.GaussianBlur(image,(5,5),0)

TOF,THRESH =cv2.threshold(gausssian_filter,0,255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

plt.figure(figsize=(15,10))
plt.subplot(1,3,1)
plt.imshow(image, cmap="gray")
plt.title("Original image")

plt.subplot(1,3,2)
plt.imshow(gausssian_filter ,cmap="gray")
plt.title("image after applyin gaussian filter")

plt.subplot(1,3,3)
plt.imshow(THRESH ,cmap="gray")
plt.title("after segmenting the image using OTSU")

"""#**edge based segmentation**"""

image = cv2.imread("/content/edgeSegmentation.jfif")
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Apply Canny edge detection
edges = cv2.Canny(gray, 100, 200)

# Apply thresholding to the edge image
threshold, binary_image = cv2.threshold(edges, 127, 255, cv2.THRESH_BINARY)


plt.figure(figsize=(15, 10))
plt.subplot(1, 3, 1)
plt.imshow(image, cmap="gray")
plt.title("Original Image")

plt.subplot(1, 3, 2)
plt.imshow(edges, cmap="gray")
plt.title("Edge Image")

plt.subplot(1, 3, 3)
plt.imshow(binary_image, cmap="gray")
plt.title("Binary Image")

plt.show()

"""#**optimal based segmentation**"""



"""#**Segmentation based on clustering**

#complete segmentation
"""

image = cv2.imread('/content/demonstration-image.webp') #open cv read the image as BGR
RGB_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) #convert to RGB

print(RGB_image.shape)

pixel_values = RGB_image.reshape((-1,3)) #convert to 2 dimension and keep the image colored

#check the shape
pixel_values.shape

pixel_values = np.float32(pixel_values)

criteria =(cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100 , 0.95)  #number of iterations = 100

_ , labels , (centers)= cv2.kmeans(pixel_values , 3 , None , criteria ,10 , cv2.KMEANS_RANDOM_CENTERS)

labels.shape
labels = labels.flatten()
labels.shape

set(labels)

centers = np.uint8(centers)

segmented_images = centers[labels]
segmented_images

segmented_images = segmented_images.reshape(image.shape)
segmented_images.shape

plt.imshow(segmented_images) #complete segmentation

"""#partial segmentation"""

#partial segemntation
#disable
masked_image = np.copy(image)
masked_image = masked_image.reshape((-1,3))
masked_image[labels==2] = [0,0,0]
masked_image = masked_image.reshape(image.shape)
plt.imshow(masked_image)

